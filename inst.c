// parse SAT instances as generated by randsat
// DON'T USE THIS WITH UNSANITIZED INPUTS!
#include <stdio.h>
#include <stdlib.h>

#include "inst.h"

int inst_parse(struct inst *inst) {
  // read from stdin
  char buf[1024]; // if a clause is longer than 1024 chars, so help me god

  if (!fgets(buf, sizeof(buf), stdin)) {
    printf("failed to read number of variables\n");
    return -1;
  }

  int N = strtol(buf, NULL, 0);
  if (N == -1) {
    printf("failed to read number of variables\n");
    return -1;
  }

  if (!fgets(buf, sizeof(buf), stdin)) {
    printf("failed to read number of clauses\n");
    return -1;
  }

  int M = strtol(buf, NULL, 0);
  if (N == -1) {
    printf("failed to read number of clauses\n");
    return -1;
  }

  struct clause *c = calloc(M, sizeof(struct clause));
  for (int i = 0; i < M; i++) {
    // read a clause
    if (!fgets(buf, sizeof(buf), stdin)) {
      printf("failed to read clause %d\n", i);
      return -1;
    }

    int k = 0;      // lits read so far
    int *l = NULL;  // lit array
    char *n = buf;  // point to next lit location
    // expect a space before the newline
    while (*n != '\n') {
      k++;
      l = realloc(l, k * sizeof(int));
      // can't handle clauses w/ more than 2^28 lits, bite me

      // find and null the next space
      char *s = n;
      while (*s != ' ') {
        s++;
      }
      *s = '\0';

      // read the lit
      l[k - 1] = strtol(n, NULL, 0);

      // next lit
      n = s + 1;
    }

    c[i].k = k;
    c[i].l = l;
  }

  inst->N = N;
  inst->M = M;
  inst->c = c;

  return 0;
}

// return 0 if sat
// return clause number (one-indexed) if unsat
int inst_check(struct inst *inst, int *v) {
  for (int a = 0; a < inst->M; a++) {
    struct clause c = inst->c[a];

    int sat = 0;
    for (int i = 0; i < c.k; i++) {
      int vi = c.l[i] > 0 ? c.l[i] : -c.l[i];
      int t = c.l[i] > 0 ? 1 : 0;

      if (v[vi - 1] == t) {
        sat = 1;
        break;
      }
    }

    if (sat == 0) {
      return a + 1;
    }
  }

  return 0;
}

void inst_show(struct inst *inst) {
  printf("%d\n", inst->N);
  printf("%d\n", inst->M);
  for (int i = 0; i < inst->M; i++) {
    int k = inst->c[i].k;
    for (int j = 0; j < k; j++) {
      printf("%d ", inst->c[i].l[j]);
    }
    printf("\n");
  }
}

void inst_free(struct inst *inst) {
  for (int i = 0; i < inst->M; i++) {
    free(inst->c[i].l);
  }
  free(inst->c);
}
